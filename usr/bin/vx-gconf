#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# Copyright (c) 2013 Jose Antonio Chavarría
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Author: Jose Antonio Chavarría <jachavar@gmail.com>

__author__ = 'Jose Antonio Chavarría'

import argparse
import os
import sys
import errno

import vx_lib as vx

GCONF_CMD            = '/usr/bin/gconftool-2'
GCONF_MANDATORY_PATH = '/etc/gconf/gconf.xml.mandatory'
GCONF_DEFAULT_PATH   = '/etc/gconf/gconf.xml.defaults'

def parse_args():
    parser = argparse.ArgumentParser(
        description='Gconf operations wrapper',
        epilog='Vitalinux utility'
    )

    parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='enable silence mode (no verbose)'
    )

    subparsers = parser.add_subparsers()
    subparser_change = subparsers.add_parser('change', help='GConf change keys')

    subparser_change.add_argument(
        '-k', '--key',
        action='store',
        help='key in GConf',
        required=True
    )

    subparser_change.add_argument(
        '-v', '--value',
        action='store',
        help='key value in GConf'
    )

    subparser_change.add_argument(
        '-t', '--type',
        action='store',
        help='key type',
        default='string',
        choices=['string', 'int', 'float', 'bool', 'pair', 'list']
    )

    subparser_change.add_argument(
        '-l', '--list-type',
        action='store',
        help='list type',
        default='string',
        choices=['string', 'int', 'float', 'bool']
    )

    subparser_change.add_argument(
        '-m', '--mandatory',
        action='store_true',
        help='mandatory values in GConf'
    )

    subparser_change.add_argument(
        '-u', '--unset',
        action='store_true',
        help='enable unset key mode'
    )

    subparser_daemon = subparsers.add_parser('daemon', help='GConf daemon options')
    group_daemon = subparser_daemon.add_mutually_exclusive_group(required=True)

    group_daemon.add_argument(
        '--on',
        action='store_true',
        help='start GConf daemon'
    )

    group_daemon.add_argument(
        '--off',
        action='store_true',
        help='stop GConf daemon'
    )

    group_daemon.add_argument(
        '-r', '--reload',
        action='store_true',
        help='reload GConf daemon'
    )

    subparser_load = subparsers.add_parser('load', help='GConf load default values')
    subparser_load.add_argument(
        '-f', '--file',
        action='store',
        help='file to load in GConf',
        required=True
    )

    return vars(parser.parse_args())

def start_gconf():
    ret, user, error = vx.execute('vx-get-user-graphic', interactive=False)
    if ret == 0:
        cmd = 'su --command="%s --spawn" %s' % (GCONF_CMD, user)
        return vx.execute(cmd, interactive=False)

    return [ret, None, None]

def stop_gconf():
    ret, user, error = vx.execute('vx-get-user-graphic', interactive=False)
    if ret == 0:
        cmd = 'su --command="%s --shutdown" %s' % (GCONF_CMD, user)
        return vx.execute(cmd, interactive=False)

    return [ret, None, None]

def reload_gconf():
    cmd = '/usr/bin/pkill gconfd-2'
    return vx.execute(cmd)

def load_file(f):
    if not os.path.isfile(f):
        return [errno.ENOENT, None, None]  # file not found

    cmd = '%s --direct --config-source=xml:readwrite:%s --load "%s"' % (
        GCONF_CMD,
        GCONF_DEFAULT_PATH,
        f
    )
    return vx.execute(cmd, interactive=False)

def unset_key(key, is_mandatory=False):
    if is_mandatory:
        source = GCONF_MANDATORY_PATH
    else:
        source = GCONF_DEFAULT_PATH

    cmd = '%s --direct --config-source=xml:readwrite:%s --unset %s' % (
        GCONF_CMD,
        source,
        key
    )
    return vx.execute(cmd, interactive=False)

def set_key(
    key,
    value,
    value_type='string',
    list_type='string',
    is_mandatory=False
):
    if is_mandatory:
        source = GCONF_MANDATORY_PATH
    else:
        source = GCONF_DEFAULT_PATH

    if value_type == 'list':
        value_type = 'list --list-type=%s' % list_type
        value = '[%s]' % value

    cmd = '%s --direct --config-source=xml:readwrite:%s --type=%s --set "%s" "%s"' % (
        GCONF_CMD,
        source,
        value_type,
        key,
        value
    )
    return vx.execute(cmd, interactive=False)

def run():
    args = parse_args()

    if not vx.user_is_root(os.environ.get('USER')):
        if not args['quiet']:
            print('User must be root to do that')
        sys.exit(errno.EPERM)  # operation not allowed

    ret = None
    output = None
    error = None

    if args.has_key('on'):
        ret, output, error = start_gconf()
    elif args.has_key('off'):
        ret, output, error = stop_gconf()
    elif args.has_key('reload'):
        ret, output, error = reload_gconf()

    if args.has_key('file'):
        ret, output, error = load_file(args['file'])

    if args.has_key('key'):
        if args.has_key('unset') and args['unset']:
            ret, output, error = unset_key(
                args['key'],
                args['mandatory'] == True
            )
        elif args.has_key('value'):
            ret, output, error = set_key(
                args['key'],
                args['value'],
                args['type'],
                args['list_type'],
                args['mandatory'] == True
            )

    if ret is not None:
        if output and output.strip() != '':
            print(output)
            print(error)
        sys.exit(ret)

    if not args['quiet']:
        print('Operation not allowed. Review help command')
    sys.exit(errno.EPERM)  # operation not allowed

if __name__ == '__main__':
    run()
